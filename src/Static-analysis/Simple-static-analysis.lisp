(uiop:define-package Reflex-semantics
  (:use #:cl))
(in-package #:Reflex-semantics)

(defun simple-static-analysis (сlosure term)
    (cond 
		((= (get-mode closure) 'prepare) (simple-static-analysis-prepare closure))
        ((= (get-mode closure) 'work) (simple-static-analysis-work closure term))))

(defun simple-static-analysis-work (closure term)
    (let* ((env (aget closure "env"))
            (agent (aget closure "agent"))
			(current-process (aget agent "current process"))
			(cur-first-state (first-state env current-process))
            (rev-cur-cond (aget agent "cur cond"))
			(cur-cond (reverse rev-cur-cond)))
        (cond 
			((is-instance term "pstate compare")
				(not (or (check-rule-1 agent term)
						(check-rule-2 agent term)
						(check-rule-3 agent term cur-cond cur-first-state current-process)
						(check-rule-4 agent term cur-cond current-process)
						(check-rule-5 agent term cur-cond current-process)
						(check-rule-6 agent term cur-cond current-process)
						
					)
				)
			)
			((is-instance term "ltime check")
				(not (check-rule-7 term cur-cond current-process))
			)
			((is-instance term "process activity")
				(not (or (check-rule-8 term cur-cond)
					(check-rule-9 term cur-cond)))
			)
			((is-instance term "process activity block")
				(not (find-if
						(lambda (formula) 
							(or (check-rule-8 term cur-cond)
								(check-rule-9 term cur-cond)))
						term))
			)
        )
	)
)

(defun check-rule-1 (agent term)
	(and (= (aget term "pstate") "error")
		(not (aget agent (aseq "cur attr" "reachE")))))

(defun check-rule-2 (agent term)
	(and (= (aget term "pstate") "stop")
		(not (aget agent (aseq "cur attr" "reachS")))
		(not (aget agent (aseq "cur attr" "startS")))))

(defun check-rule-3 (agent term cur-cond cur-first-state current-process)
	(and (string/= (aget term "pstate") cur-first-state)
		(equal (aget agent (aseq "cur attr" "process change" current-process)) 'start)
	))

(defun check-rule-4 (agent term cur-cond current-process)
	(and (string/= (aget term "pstate") "stop")
		(equal (aget agent (aseq "cur attr" "process change" current-process)) 'stop)))

(defun check-rule-5 (agent term cur-cond current-process)
	(and (string/= (aget term "pstate") "error")
		(equal (aget agent (aseq "cur attr" "process change" current-process)) 'error)))

(defun check-rule-6 (agent term cur-proc)
	(and (member-if 
			(lambda (formula) 
				(or 
					(and (or (= (aget term "pstate") "stop") (= (aget term "pstate") "error")) 
						(is-process-activity formula cur-proc 'active))
					(and (string/= (aget term "pstate") "stop") 
						(string/= (aget term "pstate") 'error)
						(is-process-activity formula cur-proc 'inactive))
					(and (string/= (aget term "pstate") "stop") 
						(is-process-activity formula cur-proc 'stop))
					(and (string/= (aget term "pstate") "error") 
						(is-process-activity formula cur-proc 'error))
					(and (= (aget term "pstate") "stop") 
						(is-process-activity formula cur-proc 'nonstop))
					(and (string/= (aget term "pstate") "error") 
						(is-process-activity formula cur-proc 'nonerror))  
				))
			cur-cond)))

(defun check-rule-7 (term cur-cond proc)
	(not (aget agent (aseq "cur attr" "reset")))
)

(defun rule-8-sub1 (cur-cond proc act)
	(and (equal act 'active)
		(or (find-if (lambda (formula) (is-process-activity formula proc 'inactive)) cur-cond)
			(find-if (lambda (formula) (is-process-activity formula proc 'stop)) cur-cond)
			(find-if (lambda (formula) (is-process-activity formula proc 'error)) cur-cond))
		(not (equal (aget agent (aseq "cur attr" "process change" proc)) 'start))
	)
)
(defun rule-8-sub2 (cur-cond proc act)
	(and (equal act 'inactive)
		(find-if (lambda (formula) (is-process-activity formula proc 'active)) cur-cond)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (or (equal act 'stop)
					(equal act 'error))))
	)
)
(defun rule-8-sub3 (cur-cond proc act)
	(and (equal act 'stop)
		(or (find-if (lambda (formula) (is-process-activity formula proc 'active)) cur-cond)
			(find-if (lambda (formula) (is-process-activity formula proc 'nonstop)) cur-cond)
			(find-if (lambda (formula) (is-process-activity formula proc 'error)) cur-cond))
		(not (equal (aget agent (aseq "cur attr" "process change" proc)) 'stop))
	)
)
(defun rule-8-sub4 (cur-cond proc act)
	(and (equal act 'error)
		(or (find-if (lambda (formula) (is-process-activity formula proc 'active)) cur-cond)
			(find-if (lambda (formula) (is-process-activity formula proc 'nonerror)) cur-cond)
			(find-if (lambda (formula) (is-process-activity formula proc 'stop)) cur-cond))
		(not (equal (aget agent (aseq "cur attr" "process change" proc)) 'error))
	)
)
(defun rule-8-sub5 (cur-cond proc act)
	(and (equal act 'nonstop)
		(find-if (lambda (formula) (is-process-activity formula proc 'stop)) cur-cond)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (or (equal act 'start)
					(equal act 'error))))
	)
)
(defun rule-8-sub6 (cur-cond proc act)
	(and (equal act 'nonerror)
		(find-if (lambda (formula) (is-process-activity formula proc 'error)) cur-cond)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (or (equal act 'start)
					(equal act 'stop))))
	)
)
(defun check-rule-8 (term cur-cond)
	(let ((proc (aget term "process"))
			(act (aget term "activity")))
		(or (rule-8-sub1 cur-cond proc act)
				(rule-8-sub2 cur-cond proc act)
				(rule-8-sub3 cur-cond proc act)
				(rule-8-sub4 cur-cond proc act)
				(rule-8-sub5 cur-cond proc act)
				(rule-8-sub6 cur-cond proc act))
	)
)

(defun rule-9-sub1 (cur-cond proc act)
	(and (equal act 'active)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (or (equal act 'stop)
					(equal act 'error))))
	)
)
(defun rule-9-sub2 (cur-cond proc act)
	(and (equal act 'inactive)
		(find-if (lambda (formula) (is-process-activity formula proc 'active)) cur-cond)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (equal act 'start)))
	)
)
(defun rule-9-sub3 (cur-cond proc act)
	(and (equal act 'stop)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (or (equal act 'start)
					(equal act 'error))))
	)
)
(defun rule-9-sub4 (cur-cond proc act)
	(and (equal act 'error)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (or (equal act 'stop)
					(equal act 'start))))
	)
)
(defun rule-9-sub5 (cur-cond proc act)
	(and (equal act 'nonstop)
		(find-if (lambda (formula) (is-process-activity formula proc 'stop)) cur-cond)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (equal act 'stop)))
	)
)
(defun rule-9-sub6 (cur-cond proc act)
	(and (equal act 'nonerror)
		(find-if (lambda (formula) (is-process-activity formula proc 'error)) cur-cond)
		(let ((act (aget agent (aseq "cur attr" "process change" proc))))
			(not (equal act 'error)))
	)
)
(defun check-rule-9 (term cur-cond)
	(let ((proc (aget term "process"))
			(act (aget term "activity")))
		(or (rule-9-sub1 cur-cond proc act)
				(rule-9-sub2 cur-cond proc act)
				(rule-9-sub3 cur-cond proc act)
				(rule-9-sub4 cur-cond proc act)
				(rule-9-sub5 cur-cond proc act)
				(rule-9-sub6 cur-cond proc act))
	)
)

(defun is-process-activity (term process activity)
	(cond 
		((is-instance term "process activity") (and (= (aget term "process") process) (= (aget term "activity" activity))))
		((is-instance term "process activity block") (find-if (lambda (act) (is-process-activity act process activity)) term))
		(t nil)))

;Написано нейронкой и надеюсь что корректно
(defun check-assertion (passed p1 p2 p3)
  "Проверяет логическое утверждение:
   ∃ s1 ∈ passed [P1(s1) ∧ (¬∃ s2 | s1 < s2 ∧ P2(s2) ∧ (∃ s3 | s2 < s3 ∧ P3(s3)) )],
   где < означает 'ранее в списке' (т.е. s2 после s1, s3 после s2, до конца списка включительно).
   Аргументы: passed — список событий; p1, p2, p3 — предикаты (функции, принимающие элемент списка).
   Возвращает T, если утверждение истинно, иначе NIL.
   Работает за O(n) времени и O(n) памяти (из-за reverse)."
  (let ((has-p3 nil)   ; есть ли в текущем суффиксе хотя бы один элемент, удовлетворяющий p3
        (has-bad nil)) ; уже есть ли в текущем суффиксе s2 с P2(s2) и после него s3 с P3(s3)
    (dolist (event (reverse passed) nil)
      ;; На момент проверки event — это кандидат на роль s1,
      ;; а текущие has-p3/has-bad описывают хвост строго ПОСЛЕ него (до конца списка).
      (when (and (funcall p1 event)
                 (not has-bad))
        (return-from check-assertion t))

      ;; Теперь включаем event в суффикс (движемся к началу списка)
      (let ((new-has-bad (or has-bad
                             (and (funcall p2 event)
                                  has-p3)))           ; если event — s2 с P2 и после него уже есть s3 с P3 → плохо
            (new-has-p3 (or (funcall p3 event)
                            has-p3)))
        (setf has-bad new-has-bad
              has-p3 new-has-p3))))
  nil)  ; если ничего не нашли, утверждение ложно

(check-assertion '("a" "b" "b" "C" "D" "a" "F")
	(lambda (el) (equal el "b"))
	(lambda (el) (equal el "C"))
	(lambda (el) (equal el "D")))
(check-assertion '(a b1 x b2 c y) 
				(lambda (el) (equal el 'a))
                (lambda (x) (member x '(b1 b2))) 
                (lambda (el) (equal el 'c)))

(att "attributes"
	:at "reachE" bool 
    :at "reachS" bool 
    :atv "startS" bool t)

(defun set-reachS (procs)
	(mapc 
		(lambda (cur-proc) 
			(if (find-if 
					(lambda (proc)
						(find-if 
							(lambda (el)
								(and (equal (aget el "process") (aget cur-proc "name"))
									(equal (aget el "change") 'stop)))
							(aget proc (aseq "analysis attributes" "pot process change")))) 
					procs)
				(aset cur-proc (aseq "analysis attributes " "reachS") t))) 
		procs))

(defun set-reachE (procs)
	(mapc 
		(lambda (cur-proc) 
			(if (find-if 
					(lambda (proc)
						(find-if 
							(lambda (el)
								(and (equal (aget el "process") (aget cur-proc "name"))
									(equal (aget el "change") 'error)))
							(aget proc (aseq "analysis attributes" "pot process change")))) 
					procs)
				(aset cur-proc (aseq "analysis attributes " "reachE") t))) 
		procs))

(defun pair-in-pot-proc-change (proc-name act potProcChange)
	(find-if 
		(lambda (pc)
			(and (equal (aget pc "process") proc-name) 
				(equal (aget pc "change") act)))
		potProcChange))

(defun set-startS (procs)
	(mapc 
		(lambda (cur-proc)
			(let ((cur-name (aget cur-proc "name"))
					(head-list (reverse (cdr (member cur-proc (reverse procs))))))
				(if (find-if
						(lambda (prev-proc)
							(and (aget prev-proc (aseq "analysis attributes" "startS"))
								(equal (aget (car (aget prev-proc "states")) (aseq "analysis attributes" "process change" cur-name)) 'start)
								(not (find-if 
										(lambda (mid-proc)
											(or (pair-in-pot-proc-change cur-name 'stop (aget mid-proc (aseq "analysis attributes" "pot process change")))))
										(member prev-proc head-list)))))
						head-list)
					(aset cur-proc (aseq "analysis attributes" "startS") nil))))
		procs))

(defun simple-static-analysis-prepare (closure)
	(let* ((program (aget closure "instance"))
			(procs (aget program "processes")))
		(set-reachS procs)
		(set-reachE procs)
		(set-startS procs))
)